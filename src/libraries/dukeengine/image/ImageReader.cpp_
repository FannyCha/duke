#include "ImageReader.h"
#include <dukeengine/file/DmaFileIO.h>
#include <dukeengine/file/MappedFileIO.h>
#include <dukeengine/file/StreamedFileIO.h>
#include <dukeengine/host/io/ImageDecoderFactory.h>
#include <iostream>

using namespace ::mikrosimage::alloc;

::mikrosimage::alloc::AlignedMallocAllocator alignedMallocAlloc;
::mikrosimage::alloc::BigAlignedBlockAllocator bigAlignedBlockAlloc;
//MallocAllocator mallocAlloc;
//NewAllocator newAlloc;
//VirtualAllocator virtualAlloc;

ImageReader::ImageReader(const ImageDecoderFactory& imageFactory) :
    m_ImageFactory(imageFactory) {
}

ImageReader::~ImageReader() {
}

void read(const ImageDecoderFactory& imageFactory, const boost::filesystem::path &path, ImageHolder &holder, FormatHandle formatHandler, const ImageDescription& description) {
    assert( description.imageDataSize > 0 );
    MemoryBlockPtr pImageMemoryBlock(new MemoryBlock(&bigAlignedBlockAlloc, description.imageDataSize));
    holder.setImageData(description, pImageMemoryBlock);
    if (!imageFactory.decodeImage(formatHandler, holder.getImageDescription()))
        std::cerr << "unable to decode " << path << std::endl;
}

bool ImageReader::load(const boost::filesystem::path &path, ImageHolder &holder) const {
    bool isFormatUncompressed;
    bool delegateReadToHost;
    const FormatHandle formatHandler = m_ImageFactory.getImageDecoder(path.extension().string().c_str(), delegateReadToHost, isFormatUncompressed);

    if (formatHandler == NULL) {
        std::cerr << "no decoder for extension \"" << path.extension() << "\"" << std::endl;
        return false;
    }

    ImageDescription description;
    const std::string filename = path.string();
    const char* c_filename = filename.c_str();

    if (delegateReadToHost) {
        // file reader
        ::mikrosimage::alloc::Allocator *pAllocator = &alignedMallocAlloc;
        if(path.extension()==".dpx")
            pAllocator = &bigAlignedBlockAlloc;
#ifdef WIN32
        DmaFileIO fileIO(pAllocator);
#else
        MappedFileIO fileIO(pAllocator);
#endif

        // reading file in memory
        const MemoryBlockPtr pFileMemoryBlock = fileIO.read(c_filename);
        if (pFileMemoryBlock == NULL) {
            std::cerr << "unable to read " << path << std::endl;
            return false;
        }

        // setting read file in description
        description.pFileData = pFileMemoryBlock->getPtr<char> ();
        description.fileDataSize = pFileMemoryBlock->size();

        // reading header
        if (!m_ImageFactory.readImageHeader(formatHandler, c_filename, description)) {
            std::cerr << "unable to open " << path << std::endl;
            return false;
        }

        assert( description.imageDataSize > 0 );
        // if pImageData is set, it means the uncompressed data was in the file in which case we must
        // save the allocated memory along with the image ( ie : in the ImageHolder )
        if (description.pImageData != NULL) {
            assert( isFormatUncompressed );
            assert( pFileMemoryBlock->hold(description.pImageData) );
            assert( pFileMemoryBlock->hold(description.pImageData + description.imageDataSize) );
            holder.setImageData(description, pFileMemoryBlock);
            return true;
        }
        read(m_ImageFactory, path, holder, formatHandler, description);
    } else {
        if (!m_ImageFactory.readImageHeader(formatHandler, c_filename, description)) {
            std::cerr << "unable to open " << path << std::endl;
            return false;
        }
        read(m_ImageFactory, path, holder, formatHandler, description);
    }
    return true;
}

void ImageReader::displayLastLoadStats() const {
    using namespace std;

    cout << "whole : ";
    cout.width(5);
    cout << m_TimeWhole.total_milliseconds();
    cout << "ms";
    cout << " getDecoder : ";
    cout.width(5);
    cout << m_TimeGetDecoder.total_milliseconds();
    cout << "ms";
    cout << " readFile : ";
    cout.width(5);
    cout << m_TimeReadFile.total_milliseconds();
    cout << "ms";
    cout << " readHeader : ";
    cout.width(5);
    cout << m_TimeReadHeader.total_milliseconds();
    cout << "ms";
    cout << " decode : ";
    cout.width(5);
    cout << m_TimeDecode.total_milliseconds();
    cout << "ms\n";
}
