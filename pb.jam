import modules ;
import feature ;
import errors ;
import type ;
import path ;
import utility ;
import "class" : new ;
import generators ;
import project ;
import toolset : flags ;

project.initialize $(__name__) ;
project pb ;

.project = [ project.current ] ;

rule init ( PROTOC )
{
    project.push-current $(.project) ;

	if ! [ path.exists $(PROTOC) ] {
		EXIT "
module $(__file__) expects the variable PROTOC to refer to the Google protobuf compiler ( aka protoc ).
Please check your configuration files ( site-config.jam or user-config.jam ).
Current value is '$(PROTOC)'" ;
	}
	
	.protoc = $(PROTOC) ;
  
	if ! $(.initialized)
	{
		.initialized = true ;
		
		type.register PROTO : proto ;
		generators.register [ new proto-generator pb.protoc : PROTO : HPP CPP ] ;
		.PREFIX = $(prefix) ;
	}
	
	project.pop-current ;
}

class proto-generator : generator 
{
  rule __init__ ( * : * )
  {
    generator.__init__ $(1) : $(2) : $(3) : $(4) : $(5) : $(6) : $(7) : $(8) : $(9) ;
  }

  rule run ( project name ? : property-set : sources * )
  {
     if $(sources[2]) {
     	EXIT (__file__) does not accept more than one source ;
     }
     if [ $(sources[1]).type ] != PROTO {
     	EXIT (__file__) accept solely PROTO files ;
     }
	 if ! $(name) {
	   name = [ generator.determine-output-name $(sources) ] ;
	   name = $(name)".pb" ;
	 }
	
	 local a = [ new action $(sources[1]) : pb.protoc : $(property-set) ] ;
	
	 local cpp_target = [ new file-target $(name).cc exact : CPP : $(project) : $(a) ] ;
	 local hpp_target = [ new file-target $(name).h exact : HPP : $(project) : $(a) ] ;
	     
	 return [ virtual-target.register $(hpp_target) ] [ virtual-target.register $(cpp_target) ] ;
  }
}

local rule ungrist ( value : suffix * )
{
	local ungristed = [ MATCH ^<p(.*)>$ : $(value:G) ] ; 
	if ! [ path.is-rooted $(ungristed) ] {
		ungristed = [ path.join [ path.pwd ] $(ungristed) ] ;
	}
	return [ path.native [ path.join $(ungristed) $(suffix) ] ] ; # normalizing
}

rule protoc ( targets * : sources * : properties * )
{
	local relative_dir = $(>:D) ;
    OUT_DIR on $(targets) = [ ungrist $(targets[0]) : $(relative_dir) ] ;
    local proto_file = [ ungrist $(>) : $(relative_dir) $(>:D=:G=) ] ;
	PROTO_FILE on $(targets) = $(proto_file) ;
}

actions protoc
{
  	$(.protoc) --cpp_out=$(OUT_DIR) --proto_path=$(PROTO_FILE:D) $(PROTO_FILE)
}
