import modules ;
import feature ;
import errors ;
import type ;
import path ;
import utility ;
import "class" : new ;
import generators ;
import project ;
import toolset : flags ;
import common ;

project.initialize $(__name__) ;
project pb ;

.project = [ project.current ] ;

rule init ( PROTOC )
{
    project.push-current $(.project) ;

	if ! [ path.exists $(PROTOC) ] {
		EXIT "
module $(__file__) expects the variable PROTOC to refer to the Google protobuf compiler ( aka protoc ).
Please check your configuration files ( site-config.jam or user-config.jam ).
Current value is '$(PROTOC)'" ;
	}
	
	.copy = [ common.copy-command ] ;
	.protoc = $(PROTOC) ;
  
	if ! $(.initialized)
	{
		.initialized = true ;
		
		type.register PROTO : proto ;
		generators.register [ new proto-generator pb.protoc : PROTO : HPP(%.pb) CPP(%.pb)  ] ;
		.PREFIX = $(prefix) ;
	}
	
	project.pop-current ;
}

class proto-generator : generator 
{
  rule __init__ ( * : * )
  {
    generator.__init__ $(1) : $(2) : $(3) : $(4) : $(5) : $(6) : $(7) : $(8) : $(9) ;
  }

  rule run ( project name ? : property-set : sources * )
  {
     if $(sources[2]) {
     	EXIT (__file__) does not accept more than one source ;
     }
     if [ $(sources[1]).type ] != PROTO {
     	EXIT (__file__) accept solely PROTO files ;
     }
	 if ! $(name) {
	   name = [ generator.determine-output-name $(sources) ] ;
	   name = $(name)".pb" ;
	 }
	
	 local a = [ new action $(sources[1]) : pb.protoc : $(property-set) ] ;
	
	 local cpp_suffix = [ type.generated-target-suffix CPP : $(property-set) ] ;
	 local hpp_suffix = [ type.generated-target-suffix HPP : $(property-set) ] ;
	     
	 type.change-generated-target-suffix CPP : $(property-set) : "cc" ;
	 type.change-generated-target-suffix HPP : $(property-set) : "h" ;
	
	 local cpp_target = [ new file-target $(name) : CPP : $(project) : $(a) ] ;
	 local hpp_target = [ new file-target $(name) : HPP : $(project) : $(a) ] ;
	     
	 type.change-generated-target-suffix CPP : $(property-set) : $(cpp_suffix) ;
	 type.change-generated-target-suffix HPP : $(property-set) : $(hpp_suffix) ;
	
	 return [ virtual-target.register $(hpp_target) ] [ virtual-target.register $(cpp_target) ] ;
  }
}

local rule ungrist ( value : suffix * )
{
	local ungristed = [ MATCH ^<p(.*)>$ : $(value:G) ] ; 
	if ! [ path.is-rooted $(ungristed) ] {
		ungristed = [ path.join [ path.pwd ] $(ungristed) ] ;
	}
	return [ path.native [ path.join $(ungristed) $(suffix) ] ] ; # normalizing
}

rule protoc ( targets * : sources * : properties * )
{
	local relative_dir = $(>:D) ;
    OUT_DIR on $(targets) = [ ungrist $(targets[0]) : $(relative_dir) ] ;
    local proto_file = [ ungrist $(>) : $(relative_dir) $(>:D=:G=) ] ;
	PROTO_FILE on $(targets) = $(proto_file) ;
	PROTO_DIR on $(targets) = $(proto_file:D) ;
}

actions protoc
{
  	$(.protoc) --cpp_out=$(OUT_DIR) --proto_path=$(PROTO_DIR) $(PROTO_FILE)
  	$(.copy) $(<[2]) $(PROTO_DIR)
}
